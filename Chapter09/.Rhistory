e
str_sub(f[1], 1,1)
as.numeric(str_sub(f[1], 1,1))
c
c
f <- rownames(c)
f
f <- str_remove_all(f, " ")
f
c
rownames(c)
f
rownames(c)
f
f <- rownames(c)
f
sub_str(f, 1, 1)
f
f <- str_remove_all(f, " ")
f
f <- rownames(c)
f
as.numeric(str_sub(f[1], 1,1))
as.numeric(str_sub(f[1], 1,1))
for(i in 1:length(f)) {
print(as.numeric(str_sub(f[i], 1,1)))
}
last_num<-as.numeric(str_sub(f[i], 1,1))
for(i in 1:length(f)) {
last_num<-as.numeric(str_sub(f[i], 1,1))
}
last_num
c
typeof(c)
class(c)
c[norw, 1]
c[nrow(c), 1]
f
c[f[length(f)], 1]
c[f[length(f)], ]
f
f
f
f[nrow(f)]
f[length(f)]
a <- f[length(f)]
str_sub(f, 3,3)
f
str_sub(f[length(f)], 3,3)
f
f[1]
str_sub(f[1], 3, 3)
str_sub(f[1], 5, 5)
str_sub(f[1], 6, 6)
str_replace_all(a,str_sub(f[1], 6, 6),'1')
b <-str_replace_all(a,str_sub(f[1], 6, 6),'1')
b
str_sub(f[1], 6, 6)
b <-str_replace_all(a, str_sub(f[length(f)], 6, 6) ,'1')
b
c[b,]
f <- rownames(c)
f[max(as.ne)]
c[x , ]
b <- summary(subsets)
c <- b$outmat; c
store <- c()
for(i in 1:length(c)) {
store <- c(store, c[nrow(c), i])
}
store
b <- summary(subsets)
c <- b$outmat; c
e <-str_replace_all(a, str_sub(f[length(f)], 6, 6) ,'1')
c[e, ]
store2 <- c()
for(i in 1:length(store1[1,])) {
if(store1[2, i] == "*" & i != length(store1[1,])) {
store2 <- paste(store2, store1[1, i], "+", sep="")
} else if(store1[2, i] == "*") {
store2 <- paste(store2, store1[1, i],  sep="")
}
}
store2
f < colnemas(c)
f
str_sub(f[length(f)])
str_sub(f[length(f)] 1, 1)
str_sub(f[length(f)], 1, 1)
c
f %in% c(8,1)
c(8,1) %in% f
f
c(8,1) %in% f[length(f)]
f[length(f)]
c("8","1") %in% f[length(f)]
c("8", "1") %in% f[length(f)]
c("8", "1") %in% strsplit(f[length(f)])
c("8", "1") %in% strsplit(f[length(f)], "")
strsplit(f[32])
length(f)
strsplit(f[32], "")
8 &in% strsplit(f[32], "")
8 %in% strsplit(f[32], "")
"8" %in% strsplit(f[32], "")
"8" %in% strsplit(f[32], "")
strsplit(f[32], "")
"8" %in% strsplit(f[32], "")
b <-str_replace_all(a, str_sub(f[length(f)], 6, 6) ,'1')
c[b,]
colnames(c[c[b,]=="*"])
c[b,]
c[b,] == "*"
colnames(c)
c[c[b,] == "*"]
colnames(c[c[b,] == "*"])
c[c[b,]=="*"]
c[b,]=="*"
colnames(c[b,]=="*")
c[b,]=="*"
k <-c[b,]=="*"
k
colnames(k)
typeof(k)
class(k)
str_remove_all(k, F)
str_remove_all(k, "FALSE")
length(f)
f
rownames(c)
str_sub(rownames(c), 1,1)
str_sub(rownames(c), 1,1) == 8
max(str_sub(rownames(c), 1,1))
k <- str_sub(rownames(c),1,1)
max(k,1,1))
max(k,1,1)
k = max(k, 1, 1)
k <- str_sub(rownames(c),1,1)
k == max(k, 1, 1)
f
f <- colnames(c)
f
f <- rownames(c)
f <- rownames(c)
f
k == max(k, 1, 1)
str_sub(rownames(c), 6, 6)
str_sub(rownames(c), 6, 6) == 1
l <- str_sub(rownames(c), 6, 6) == 1
l <- str_sub(rownames(c), 6, 6)
f
f[k == max(k) & l == 1]
c[f[k == max(k) & l == 1],]
f <- rownames(c)
l <- str_sub(rownames(c), 6, 6)
k <- str_sub(rownames(c), 1, 1)
k == max(k, 1, 1)
c[f[k == max(k) & l == 1],]
library(stringr)
c[f[k == max(k) & l == 1],]
c[f[k == max(k) & l == 1],] == "*"
c
colnames(c)
p <- c[f[k == max(k) & l == 1],] == "*"
colneams(c[p==T])
colnames(c[p==T])
colnames(c)
class(p)
as.data.frame(p)
as.matrix(p)
as.data.frame(p)
q <- as.data.frame(p)
rownames(q[p==T])
q$p == T
q[q$p == T]
q[q$p==T]
rownames(q)
p <- c[f[k == max(k) & l == 1],] == "*"
p
q <- as.data.frame(p)
q
q <- subset(q, q$p == T)
q
rownames(q)
f <- rownames(c); f
p <- c[f[k == max(k) & l == 1],] == "*"; p
l <- str_sub(rownames(c), 6, 6)
k <- str_sub(rownames(c), 1, 1)
k <- str_sub(rownames(c), 1, 1)
k <- str_sub(rownames(c), 1, 1); k
l <- str_sub(rownames(c), 6, 6); l
p <- c[f[k == max(k) & l == 1],] == "*"; p
k <- str_sub(rownames(c), 1, 1); typeof(k)
max(k)
k <- str_sub(rownames(c), 1, 1); k
p <- c[f[k == max(k) & l == 1],] == "*"; p
q <- as.data.frame(p)
q <- subset(q, q$p == T)
rownames(q)
rownames(q)[1]
t <- rownames(q)
r <- c()
r <- c()
for (i in length(t)) {
r <- paste(r, t[i], "+")
}
r
r <- c()
for (i in 1:length(t)) {
r <- paste(r, t[i], "+")
}
r
r <- paste(r, t[i], "+", sep="")
r <- c()
for (i in 1:length(t)) {
r <- paste(r, t[i], "+", sep="")
}
r
for (i in 1:length(t)) {
ifelse(i < length(t), r <- paste(r, t[i], "+", sep=""), r <- paste(r, t[i], sep=""))
}
r
ifelse(1 < 3, 3, 2)
ifelse(1 , 3, 2)
ifelse(0 , 3, 2)
length9t
length(t)
t <- rownames(q); t
f <- rownames(c); f
c <- b$outmat; c
c <- b$outmat; c
subsets <- regsubsets(medv ~ ., data=Boston,
method='exhaustive', nbest=4)
plot(subsets)
fit <- lm(medv ~ zn + chas + nox + rm + dis + ptratio + black + lstat, data=Boston)
summary(fit)
# 4. MASS 패키지를 설치하고, 이 패키지 안에 있는 Boston 데이터셋을 이용하여
# Boston 인근의 집값을 결정하는 다중회귀 모델을 만드시오.
library(MASS)
str(Boston)
head(Boston)
names(Boston)
library(leaps)
subsets <- regsubsets(medv ~ ., data=Boston,
method='seqrep', nbest=4)
subsets <- regsubsets(medv ~ ., data=Boston,
method='exhaustive', nbest=4)
b <- summary(subsets)
c <- b$outmat; c
b <- summary(subsets); b
r <- c()
for (i in 1:length(t)) {
ifelse(i < length(t), r <- paste(r, t[i], "+", sep=""), r <- paste(r, t[i], sep=""))
}
length(t)
r
b <- summary(subsets); b
c <- summary(subsets)$outmat; c
colnames(c[c[b,]=="*"])
f <- rownames(c); f
case <- summary(subsets)$outmat; case
rown <- rownames(c); f
rown <- rownames(c); rown
num2 <- str_sub(rownames(c), 1, 1); num2
num1 <- str_sub(rownames(c), 6, 6); num1
choice <- case[f[num1 == max(num1) & num2 == 1],] == "*";
df_c <- as.data.frame(choice)
df_c <- as.data.frame(choice); df_c
df_c <- subset(df_c, df_c$choice == T)
row_df_c <- rownames(df_c); row_df_c
tmp <- c()
for (i in 1:length(t)) {
ifelse(i < length(t), tmp <- paste(r, t[i], "+", sep=""), tmp <- paste(r, t[i], sep=""))
}
tmp <- c()
for (i in 1:length(row_df_c)) {
ifelse(i < length(row_df_c), tmp <- paste(r, row_df_c[i], "+", sep=""), tmp <- paste(r, row_df_c[i], sep=""))
}
tmp
tmp <- c()
for (i in 1:length(row_df_c)) {
ifelse(i < length(row_df_c), tmp <- paste(r, row_df_c[i], "+", sep=""), tmp <- paste(r, row_df_c[i], sep=""))
}
tmp
case <- summary(subsets)$outmat; case
library(stringr)
case <- summary(subsets)$outmat; case
rown <- rownames(c); rown
num1 <- str_sub(rownames(c), 6, 6); num1
num2 <- str_sub(rownames(c), 1, 1); num2
choice <- case[f[num1 == max(num1) & num2 == 1],] == "*";
df_c <- as.data.frame(choice); df_c
df_c <- subset(df_c, df_c$choice == T)
row_df_c <- rownames(df_c); row_df_c
tmp <- c()
for (i in 1:length(row_df_c)) {
ifelse(i < length(row_df_c), tmp <- paste(r, row_df_c[i], "+", sep=""), tmp <- paste(r, row_df_c[i], sep=""))
}
tmp
library(stringr)
case <- summary(subsets)$outmat; case
rown <- rownames(c); rown
num1 <- str_sub(rownames(c), 6, 6); num1
num2 <- str_sub(rownames(c), 1, 1); num2
choice <- case[f[num1 == max(num1) & num2 == 1],] == "*";
df_c <- as.data.frame(choice); df_c
df_c <- subset(df_c, df_c$choice == T)
row_df_c <- rownames(df_c); row_df_c
library(stringr)
case <- summary(subsets)$outmat; case
rown <- rownames(case); rown
num1 <- str_sub(rownames(case), 6, 6); num1
num2 <- str_sub(rownames(case), 1, 1); num2
choice <- case[f[num1 == max(num1) & num2 == 1],] == "*";
df_c <- as.data.frame(choice); df_c
df_c <- subset(df_c, df_c$choice == T)
row_df_c <- rownames(df_c); row_df_c
num2 <- str_sub(rownames(case), 1, 1); num2
case <- summary(subsets)$outmat; case
rown <- rownames(case); rown
num1 <- str_sub(rownames(case), 6, 6); num1
num2 <- str_sub(rownames(case), 1, 1); num2
num1 <- str_sub(rownames(case), 1, 1); num1num2 <- str_sub(rownames(case), 6, 6); num2
num1 <- str_sub(rownames(case), 1, 1); num1
num2 <- str_sub(rownames(case), 6, 6); num2
choice <- case[f[num1 == max(num1) & num2 == 1],] == "*";
df_c <- as.data.frame(choice); df_c
df_c <- subset(df_c, df_c$choice == T)
row_df_c <- rownames(df_c); row_df_c
tmp <- c()
for (i in 1:length(row_df_c)) {
ifelse(i < length(row_df_c), tmp <- paste(r, row_df_c[i], "+", sep=""), tmp <- paste(r, row_df_c[i], sep=""))
}
tmp
tmp <- c()
for (i in 1:length(row_df_c)) {
ifelse(i < length(row_df_c), tmp <- paste(tmp, row_df_c[i], "+", sep=""), tmp <- paste(tmp, row_df_c[i], sep=""))
}
tmp
nox
+
2
case <- summary(subsets)$outmat; case
# 4. MASS 패키지를 설치하고, 이 패키지 안에 있는 Boston 데이터셋을 이용하여
# Boston 인근의 집값을 결정하는 다중회귀 모델을 만드시오.
library(MASS)
str(Boston)
head(Boston)
names(Boston)
library(leaps)
subsets <- regsubsets(medv ~ ., data=Boston,
method='seqrep', nbest=4)
subsets <- regsubsets(medv ~ ., data=Boston,
method='exhaustive', nbest=4)
plot(subsets)
fit <- lm(medv ~ zn + chas + nox + rm + dis + ptratio + black + lstat, data=Boston)
summary(fit)
plot(subsets)
# 4. MASS 패키지를 설치하고, 이 패키지 안에 있는 Boston 데이터셋을 이용하여
# Boston 인근의 집값을 결정하는 다중회귀 모델을 만드시오.
library(MASS)
str(Boston)
head(Boston)
names(Boston)
library(leaps)
subsets <- regsubsets(medv ~ ., data=Boston,
method='seqrep', nbest=4)
subsets <- regsubsets(medv ~ ., data=Boston,
method='exhaustive', nbest=4)
plot(subsets)
fit <- lm(medv ~ zn + chas + nox + rm + dis + ptratio + black + lstat, data=Boston)
summary(fit)
tmp
lm(medv ~ tmp, data=Boston)
tmp
tmp
fit2 <- lm(medv ~ zn + chas + nox + rm + dis + ptratio + black + lstat, data=Boston)
a<-"zn + chas + nox + rm + dis + ptratio + black + lstat"
fit2 <- lm(medv ~ a, data=Boston)
fit2 <- lm(medv ~ get(a), data=Boston)
row_df_c <- rownames(df_c); row_df_c
length(row_df_c)
?lm
fomula <- paste("medv", "~", tmp)
fomula
lm(formula = fomula, data= Boston)
fit <- lm(medv ~ zn + chas + nox + rm + dis + ptratio + black + lstat, data=Boston)
a<- lm(formula = fomula, data= Boston)
summary(a)
form <- paste("medv", "~", tmp)
a<- lm(formula = form, data= Boston)
summary(a)
# 4. MASS 패키지를 설치하고, 이 패키지 안에 있는 Boston 데이터셋을 이용하여
# Boston 인근의 집값을 결정하는 다중회귀 모델을 만드시오.
library(MASS)
names(Boston)
library(leaps)
subsets <- regsubsets(medv ~ ., data=Boston,
method='seqrep', nbest=4)
subsets <- regsubsets(medv ~ ., data=Boston,
method='exhaustive', nbest=4)
library(stringr)
case <- summary(subsets)$outmat; case
rown <- rownames(case); rown
num1 <- str_sub(rownames(case), 1, 1); num1
num2 <- str_sub(rownames(case), 6, 6); num2
choice <- case[f[num1 == max(num1) & num2 == 1],] == "*";
df_c <- as.data.frame(choice); df_c
df_c <- subset(df_c, df_c$choice == T)
row_df_c <- rownames(df_c); row_df_c
tmp <- c()
for (i in 1:length(row_df_c)) {
ifelse(i < length(row_df_c), tmp <- paste(tmp, row_df_c[i], "+", sep=""), tmp <- paste(tmp, row_df_c[i], sep=""))
}
tmp
lm(medv ~ tmp, data=Boston)
form <- paste("medv", "~", tmp)
a<- lm(formula = form, data= Boston)
summary(a)
y <- medv
y <- "medv"
subsets <- regsubsets(y ~ ., data=Boston,
method='seqrep', nbest=4)
y <- "medv ~ ."
subsets <- regsubsets(y, data=Boston,
method='seqrep', nbest=4)
subsets <- regsubsets(get(y), data=Boston,
method='seqrep', nbest=4)
subsets <- regsubsets(y, data=Boston,
method='seqrep', nbest=4)
?regsubsets()
y <- "medv ~ ."
subsets <- regsubsets(x=y, data=Boston,
method='seqrep', nbest=4)
subsets <- regsubsets(medv, data=Boston,
method='seqrep', nbest=4)
# 4. MASS 패키지를 설치하고, 이 패키지 안에 있는 Boston 데이터셋을 이용하여
# Boston 인근의 집값을 결정하는 다중회귀 모델을 만드시오.
library(MASS)
library(stringr)
library(leaps)
subsets <- regsubsets(medv ~ ., data=Boston,
method='seqrep', nbest=4)
y <- "medv ~ ."
subsets <- regsubsets(medv, data=Boston,
method='seqrep', nbest=4)
y <- paste("medv","~.")
subsets <- regsubsets(medv ~. , data=Boston,
method='seqrep', nbest=4)
subsets <- regsubsets(y, data=Boston,
method='seqrep', nbest=4)
subsets <- regsubsets(x=y, data=Boston,
method='seqrep', nbest=4)
str_locate(colnames(Boston), "medv")
!is.na(str_locate(colnames(Boston), "medv"))
length(Boston)
subsets <- regsubsets(medv ~ ., data=Boston,
method='seqrep', nbest=4)
"medv ~ ."
y <- "medv ~ ."
subsets <- regsubsets(y, data=Boston,
method='seqrep', nbest=4)
subsets <- regsubsets(get(y), data=Boston,
method='seqrep', nbest=4)
get(y)
y<- medv
get(y)
y<- Boston$medv
y
get(y)
y <- Boston$medv
get(y)
subsets <- regsubsets(y ~., data=Boston,
method='seqrep', nbest=4)
subsets
subsets <- regsubsets(medv ~ ., data=Boston,
method='seqrep', nbest=4)
subsets
data <- Boston
data <- "Boston"
y <- "medv"
data$y
Boston$y
y <- "medv"
Boston$y
Boston$get(y)
get(Boston$y)
Boston$medv
paste("Boston", $, "medv", sep="")
paste("Boston", "$", "medv", sep="")
a <- paste("Boston", "$", "medv", sep="")
a
get(a)
subsets <- regsubsets(a ~ ., data=Boston,
method='seqrep', nbest=4)
subsets <- regsubsets(get(a) ~ ., data=Boston,
method='seqrep', nbest=4)
Boston$medv
colanmes(Boston) == "medv"
colnames(Boston) == "medv"
subset(Boston, colnames(Boston) == "medv")
a <- subset(Boston, colnames(Boston) == "medv")
a
colnames(boston)
colnames(Boston)
colnames(Boston) == "medv"
a <- subset(Boston, colnames(Boston) == "medv")
a
head(a)
head(Boston)
head(a)
head(Boston)
